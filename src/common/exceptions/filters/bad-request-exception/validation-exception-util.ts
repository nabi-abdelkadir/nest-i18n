/**
 * Generates a formatted validation message with field metadata prefix.
 *
 * This helper is used to attach a metadata prefix to a custom validation message.
 * The prefix contains a list of field names (joined with '|'), allowing the consumer
 * (e.g., a global exception filter) to later extract which field(s) the message is about.
 *
 * Example:
 * ```ts
 * createFieldPrefixedMessage(['cartItemsIds', 'orderItems'], 'You must provide at least one.');
 * // Returns: "__cartItemsIds|orderItems__:You must provide at least one."
 * ```
 *
 * @param field - Array of field names involved in the validation rule
 * @param message - The actual validation message to show to the user
 * @returns A single string with prefixed field metadata
 */
export function createFieldPrefixedMessage(field: string[], message: string): string {
  const fieldPrefix = `__${field.sort().join('|')}__:`; // Sort ensures consistent key ordering
  return `${fieldPrefix}${message}`;
}

/**
 * Extracts field name(s) and a clean message from a prefixed validation message.
 *
 * This function is typically used in global exception filters to separate
 * validation metadata (field names) from the actual user-facing message.
 * It supports:
 *  - Prefixed messages generated by `createFieldPrefixedMessage`
 *  - Basic messages like "fieldName should not be empty"
 *  - Fallbacks to `_global` when no field info is found
 *
 * Example:
 * ```ts
 * extractFieldFromMessage("__cartItemsIds|orderItems__:You must provide one.");
 * // Returns: { field: "cartItemsIds|orderItems", message: "You must provide one." }
 *
 * extractFieldFromMessage("clientFax should not be empty");
 * // Returns: { field: "clientFax", message: "clientFax should not be empty" }
 * ```
 *
 * @param message - The raw message that may contain field metadata
 * @returns An object with the `field` name(s) and clean `message`
 */
export function extractFieldFromMessage(message: string): { field: string; message: string } {
  // Match custom format: __field1|field2__:Message
  const prefixMatch = message.match(/^__(.+?)__:(.*)/);

  if (prefixMatch) {
    return {
      field: prefixMatch[1],
      message: prefixMatch[2].trim(),
    };
  }

  // Match standard validation messages like: "fieldName must be a string"
  const standardMatch = message.match(/^([a-zA-Z0-9_]+)\s(.*)/);
  if (standardMatch) {
    return {
      field: standardMatch[1],
      message: message,
    };
  }

  // Fallback for completely unstructured messages
  return {
    field: '_global',
    message: message,
  };
}
